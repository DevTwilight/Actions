name: Auto Changelog
description: Generates a changelog from commit messages

inputs:
  repo:
    description: 'Target repository (Repo B)'
    required: true
  commit_message:
    description: 'Commit message pattern for version bumps'
    required: true
  sections:
    description: 'Mapping of commit keywords to changelog section titles'
    required: true
  file:
    description: 'Path to changelog file to write/update'
    required: true
  token:
    description: 'GitHub token with write access to Repo B'
    required: true
  title:
    description: 'Title for the changelog version block'
    required: true

outputs:
  version:
    description: 'The detected version from the changelog'

runs:
  using: "composite"
  steps:
    - name: Generate Changelog
      id: set-version
      shell: pwsh
      env:
        REPO: ${{ github.repository }}
      run: |
        $sourceRepoUrl = "https://github.com/${{ github.repository }}"
        $targetRepoUrl = "https://github.com/${{ inputs.repo }}"

        $commitMessagePattern = "${{ inputs.commit_message }}"
        $sectionsInput = "${{ inputs.sections }}"
        $filePath = "${{ inputs.file }}"
        $versionTitle = "${{ inputs.title }}"

        # Parse sections input
        $sections = @{}
        $sectionsInput -split "`n" | ForEach-Object {
          $_ = $_.Trim()

          if ([string]::IsNullOrWhiteSpace($_)) {
            return
          }

          $sectionParts = $_ -split ":", 2

          if ($sectionParts.Count -ne 2 -or [string]::IsNullOrWhiteSpace($sectionParts[0]) -or [string]::IsNullOrWhiteSpace($sectionParts[1])) {
            Write-Error "Invalid section format: '$_'. Expected format: 'Keyword: Title'"
            exit 1
          }

          $key = $sectionParts[0].Trim()
          $value = $sectionParts[1].Trim()
          $sections[$key] = $value
        }

        foreach ($keyword in $sections.Keys) {
          if (-not $sections[$keyword]) {
            Write-Warning "No section heading provided for keyword '$keyword'."
            exit 1
          }
        }

        Write-Host "Fetching commit history..."
        $log = git log --pretty=format:"%H|%s"
        $commits = $log -split "`n" | ForEach-Object {
          $parts = $_ -split "\|", 2
          [PSCustomObject]@{ Hash = $parts[0]; Message = $parts[1] }
        }

        # Updated regex pattern to match version bumps like `Bump version to X.Y.Z`
        $pattern = [regex]::Escape($commitMessagePattern) + '\s+\d+\.\d+(?:\.\d+)?'
        
        $versionBumps = $commits | Where-Object { $_.Message -match "^$pattern$" }

        if ($versionBumps.Count -eq 0) {
          Write-Warning "No version bump commit found using message '$commitMessagePattern'."
          exit 1
        }

        $currentBump = $versionBumps[0]
        $versionMatch = [regex]::Match($currentBump.Message, '\d+\.\d+(?:\.\d+)?')
        $version = $versionMatch.Value

        Write-Host "Detected version bump: $version"
        echo "version=$version" >> $env:GITHUB_OUTPUT

        $startIndex = $commits.IndexOf($currentBump)
        $rangeCommits = $commits[($startIndex + 1)..($commits.Count - 1)]

        $entries = @{}
        $seenMessages = @{}

        foreach ($commit in $rangeCommits) {
          foreach ($keyword in $sections.Keys) {
            $pattern = "^$keyword\s*:\s*(.+)$"
            if ($commit.Message -match $pattern) {
              $clean = $matches[1].Trim()
              if ($seenMessages.ContainsKey($clean)) {
                continue
              }
              $seenMessages[$clean] = $true
              $clean = $clean -replace "PR #(\d+)", "[PR #`$1]($sourceRepoUrl/pull/`$1)"
              $clean = $clean -replace "#(\d+)", "[#`$1]($sourceRepoUrl/issues/`$1)"
              if (-not $entries.ContainsKey($keyword)) {
                $entries[$keyword] = @()
              }
              $entries[$keyword] += "- $clean"
              break
            }
          }
        }

        if ($entries.Count -eq 0) {
          Write-Warning "No matching commit messages found for changelog."
          exit 1
        }

        $newBlock = @()
        $newBlock += $versionTitle
        $newBlock += ""

        foreach ($keyword in $sections.Keys) {
          if ($entries.ContainsKey($keyword)) {
            $newBlock += "### $($sections[$keyword])"
            $newBlock += ""
            $newBlock += $entries[$keyword]
            $newBlock += ""
          }
        }

        $fileDir = Split-Path -Path $filePath -Parent
        if (-not (Test-Path $fileDir)) {
          Write-Host "Creating directory for changelog: $fileDir"
          New-Item -ItemType Directory -Path $fileDir | Out-Null
        }

        $newBlock | Set-Content -Path $filePath -Encoding UTF8
        Write-Host "Changelog written to $filePath"
