name: 'Auto Changelog'
description: 'Generates a changelog from commit messages'

inputs:
  commit_message:
    description: 'Commit message pattern for version bumps (e.g., "Bump version to ")'
    required: true
  sections:
    description: 'Mapping of commit keywords to changelog section titles (e.g., "Feat: New features")'
    required: true
  file:
    description: 'Path to changelog file to write/update (e.g., Devlog.md)'
    required: true
  token:
    description: 'GitHub token with write access to the repository'
    required: true
  title:
    description: 'Title for the changelog version block (e.g., "## Version 1.2.3")'
    required: true

runs:
  using: "composite"
  steps:
    - name: Generate Changelog
      shell: pwsh
      env:
        REPO: ${{ github.repository }}
      run: |
        $repoUrl = "https://github.com/${{ github.repository }}"
        $commitMessagePattern = "${{ inputs.commit_message }}"
        $sectionsInput = "${{ inputs.sections }}"
        $filePath = "${{ inputs.file }}"
        $versionTitle = "${{ inputs.title }}"

        # Ensure the title starts with '## ' for markdown heading
        if (-not $versionTitle.StartsWith("## ")) {
            $versionTitle = "## $versionTitle"
        }

        # Parse section mappings dynamically from the input
        $sections = @{}
        $sectionsInput -split "`n" | ForEach-Object {
          $_ = $_.Trim()
          if ($_ -and ($_ -match "^.+:.+$")) {
            $key, $value = $_ -split ":", 2
            $sections[$key.Trim()] = $value.Trim()
          }
        }

        Write-Information "Fetching commit history..." -InformationAction Continue
        $log = git log --pretty=format:"%H|%s"
        $commits = $log -split "`n" | ForEach-Object {
          $parts = $_ -split "\|", 2
          [PSCustomObject]@{ Hash = $parts[0]; Message = $parts[1] }
        }

        # Detect version bumps using the commit message pattern
        $pattern = [regex]::Escape($commitMessagePattern) + '\s*\d+\.\d+(?:\.\d+)?(?:-[\w\d]+)?'
        $versionBumps = $commits | Where-Object { $_.Message -match "^$pattern$" }

        # If no version bump found, exit
        if ($versionBumps.Count -eq 0) {
          Write-Warning "No version bump commits found with pattern '$commitMessagePattern'."
          exit 1
        }

        # If only one version bump found, treat it as the current version
        $currentBump = $versionBumps[0]
        $versionMatch = [regex]::Match($currentBump.Message, '\d+\.\d+(?:\.\d+)?(?:-[\w\d]+)?')
        $version = $versionMatch.Value

        # Prevent duplicate version bumps
        $duplicate = $versionBumps | Where-Object {
          $_.Message -eq "$commitMessagePattern$version" -and $_.Hash -ne $currentBump.Hash
        }

        if ($duplicate.Count -gt 0) {
          Write-Warning "Duplicate version bump found for version $version. Skipping changelog generation."
          exit 0
        }

        # Determine the range of commits between bumps
        $startIndex = $commits.IndexOf($currentBump)
        $endIndex = if ($versionBumps.Count -ge 2) {
          $commits.IndexOf($versionBumps[1])
        } else {
          $commits.Count
        }

        $rangeCommits = if ($startIndex -lt $endIndex) {
          $commits[($startIndex + 1)..($endIndex - 1)]
        } else {
          $commits[($endIndex + 1)..($startIndex - 1)]
        }

        # Initialize entries dynamically based on sections
        $entries = @{}
        foreach ($section in $sections.Keys) {
          $entries[$section] = @()
        }

        $processedMessages = @()

        # Process commits
        foreach ($commit in $rangeCommits) {
          foreach ($keyword in $sections.Keys) {
            $pattern = "^$keyword\s*:\s*(.+)$"
            if ($commit.Message -match $pattern) {
              $clean = $matches[1].Trim()

              # Check for duplicate commit messages
              if ($processedMessages -notcontains $clean) {
                $processedMessages += $clean

                # Link PRs/issues
                $clean = $clean -replace "(?i)\bPR #(\d+)\b", "[PR #`$1]($repoUrl/pull/`$1)"
                $clean = $clean -replace "(?<!PR )#(\d+)", "[#`$1]($repoUrl/issues/`$1)"

                # Add this message to the changelog entries
                $entries[$keyword] += "- $clean"
              }
              break
            }
          }
        }

        # Build changelog block
        $newBlock = @()
        $newBlock += $versionTitle
        $newBlock += ""

        # Add entries for each section
        foreach ($keyword in $sections.Keys) {
          if ($entries[$keyword].Count -gt 0) {
            $newBlock += "### $($sections[$keyword])"
            $newBlock += ""
            $newBlock += $entries[$keyword] -join "`n"
            $newBlock += ""
          }
        }

        # Ensure directory exists
        $fileDir = Split-Path -Path $filePath -Parent
        if (-not (Test-Path $fileDir)) {
          New-Item -ItemType Directory -Path $fileDir | Out-Null
        }

        # Append or create changelog file
        Add-Content -Path $filePath -Value ($newBlock -join "`n")
        Write-Information "Changelog written to $filePath" -InformationAction Continue
