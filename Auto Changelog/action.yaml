name: Auto Changelog

inputs:
  repo:
    required: true
  commit_message:
    required: true
  sections:
    required: true
  file:
    required: true
  token:
    required: true
  title:
    required: true  # Version title input

outputs:
  version:
    value: ${{ steps.set-version.outputs.version }}

runs:
  using: "composite"
  steps:
    - name: Generate Changelog
      id: set-version
      shell: pwsh
      env:
        REPO: ${{ github.repository }}
      run: |
        # Repo A (Source Repo URL) where the action is running
        $sourceRepoUrl = "https://github.com/${{ github.repository }}"

        # Repo B (Target Repo URL) where the changelog will be committed
        $targetRepoUrl = "https://github.com/${{ inputs.repo }}"

        # Input variables
        $commitMessagePattern = "${{ inputs.commit_message }}"
        $sectionsInput = "${{ inputs.sections }}"
        $filePath = "${{ inputs.file }}"
        $title = "${{ inputs.title }}"  # Version title
        
        # Parse sections input
        $sections = @{}
        $sectionsInput -split "`n" | ForEach-Object {
          $sectionParts = $_.Trim() -split ":", 2
          if ($sectionParts.Count -eq 2) {
            $sections[$sectionParts[0].Trim()] = $sectionParts[1].Trim()
          } else {
            Write-Error "Invalid section format: $($_)"
            exit 1
          }
        }

        # Check for missing section headings and raise a warning
        foreach ($keyword in $sections.Keys) {
          if (-not $sections[$keyword]) {
            Write-Warning "No section heading provided for keyword '$keyword'."
            exit 1
          }
        }

        # Fetch commit history from Repo A
        Write-Information "Fetching commit history from source repository ($sourceRepoUrl)..."
        $log = git log --pretty=format:"%H|%s"
        $commits = $log -split "`n" | ForEach-Object {
          $parts = $_ -split "\|", 2
          [PSCustomObject]@{ Hash = $parts[0]; Message = $parts[1] }
        }

        # Search for version bump commits
        $pattern = [regex]::Escape($commitMessagePattern) + '\d+\.\d+(?:\.\d+)?(?:-dev)?'
        $versionBumps = $commits | Where-Object { $_.Message -match "^$pattern$" }

        if ($versionBumps.Count -eq 0) {
          Write-Warning "No version bump commit found using message '$commitMessagePattern'. Cannot generate changelog."
          exit 1
        }

        # Extract version from the latest bump
        $currentBump = $versionBumps[0]
        $versionMatch = [regex]::Match($currentBump.Message, '\d+\.\d+(?:\.\d+)?(?:-dev)?')
        $version = $versionMatch.Value

        Write-Information "Detected version bump: $version"

        echo "version=$version" >> $env:GITHUB_OUTPUT

        # Process commits for changelog generation, excluding version bump commit
        $startIndex = $commits.IndexOf($currentBump)
        $rangeCommits = $commits[($startIndex + 1)..($commits.Count - 1)]
        
        $entries = @()
        $seenMessages = @{}

        foreach ($commit in $rangeCommits) {
          foreach ($keyword in $sections.Keys) {
            $pattern = "^$keyword\s*:\s*(.+)$"
            if ($commit.Message -match $pattern) {
              $clean = $matches[1].Trim()

              # Skip duplicate commit messages
              if ($seenMessages.ContainsKey($clean)) {
                continue
              }

              $seenMessages[$clean] = $true

              # Convert issue/PR links in commit message
              $clean = $clean -replace "PR #(\d+)", "[PR #`$1]($sourceRepoUrl/pull/`$1)"
              $clean = $clean -replace "#(\d+)", "[#`$1]($sourceRepoUrl/issues/`$1)"

              $entries += "- $clean"
              break
            }
          }
        }

        # Check if changelog entries exist
        if ($entries.Count -eq 0) {
          Write-Warning "No commits found matching the defined sections and commit messages."
          exit 1
        }

        # Prepare the changelog block dynamically based on inputs
        $newBlock = @()
        $newBlock += $title  # Use the 'title' input for the version heading
        $newBlock += ""  # Add a blank line for separation

        # Loop over each section to generate content for the changelog
        foreach ($keyword in $sections.Keys) {
            $sectionTitle = $sections[$keyword]  # Get the section title
            if ($sectionTitle) {
                $newBlock += "### $keyword"  # Add section title (like 'Features', 'Bug Fixes', etc.)
                $newBlock += ""
                $newBlock += $sectionTitle  # Add the entries for the section (from the commit messages)
                $newBlock += ""
            }
        }

        # Now, check if the file already exists, and append accordingly
        $existingContent = ""
        if (Test-Path $filePath) {
            $existingContent = Get-Content -Path $filePath -Raw
        }

        # Append or create the changelog file
        if ($existingContent -ne "") {
            # Ensure the changelog has the new version at the top
            Write-Information "Appending changelog content to the existing file."
            $existingContent = $newBlock + $existingContent
        } else {
            Write-Information "Creating a new changelog file."
            $existingContent = $newBlock
        }

        # Write the updated changelog content to the file
        Write-Information "Writing the changelog to file: $filePath"
        $existingContent | Set-Content -Path $filePath -Encoding UTF8
        Write-Information "Changelog file created/updated successfully at $filePath"